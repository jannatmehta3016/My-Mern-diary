### ðŸ“Œ Topics Covered:
HTTP Status Codes, Postman Testing, and Express Error Handling

### ðŸ’» What I Did:
Today's focus was on **testing backend APIs** more effectively and handling different types of server responses. I deepened my understanding of how the backend communicates with the client using **HTTP status codes**, and how to **test APIs with Postman**.
  ---

### ðŸŒ HTTP Status Codes:
I explored the most commonly used status codes in Express:
- `200 OK` â€“ Success
- `201 Created` â€“ Resource created successfully
- `400 Bad Request` â€“ Client sent incorrect input
- `401 Unauthorized` â€“ User is not authenticated
- `404 Not Found` â€“ Resource doesn't exist
- `500 Internal Server Error` â€“ Something went wrong on the server

Used them like this:
```js
app.get('/api/test', (req, res) => {
  res.status(200).send('API is working fine!');
});
```

This helped me communicate more clearly with the frontend by sending the appropriate status codes based on the response logic.

---

### ðŸ” Postman Testing:
I tested multiple GET and POST routes using **Postman**:
- Sent JSON data via `POST` requests
- Observed headers and body of responses
- Simulated failed requests to trigger error handling

This made it super easy to interact with APIs without writing frontend code.

---

### âš ï¸ Error Handling:
Learned how to use **Express error middleware** to manage exceptions gracefully:
```js
  This centralized the error management process so I didn't need to duplicate try-catch logic everywhere.
app.use((err, req, res, next) => {
  ---

### ðŸ§  Reflections:
  Postman became an essential tool for me today. I realized how crucial status codes and error messages are in building real-world applications. Error handling is not just about catching bugs â€” it's about making the app stable and developer-friendly.

first commit
4 months ago

I'm starting to feel more confident interacting with APIs and simulating frontend scenarios. The more I test, the clearer things become.

---

âœ… **Next Goal:** Implement request validation and explore `dotenv` for environment configs.



---


final Summer training diary
3 months ago
## Day 8 â€“ 1 July 2025  

first commit
4 months ago
### ðŸ“Œ Topics Covered:
Environment Variables with dotenv, Express Middleware Deep Dive, and Route Separation

### ðŸ’» What I Did:
Today, I learned how to better structure and secure my backend code. I focused on using **environment variables**, creating **modular Express route files**, and understanding the **power of middleware** in Express.

---

### ðŸ” dotenv â€“ Environment Configuration:
I installed the `dotenv` package to manage sensitive data like database URLs, ports, and secret keys. This allowed me to separate configuration from code:
```bash
npm install dotenv
```
Then, I created a `.env` file:
```
PORT=5000
MONGO_URI=mongodb://localhost:27017/myapp
JWT_SECRET=supersecretkey
```

In my code, I used:
```js
import dotenv from 'dotenv';
dotenv.config();

const PORT = process.env.PORT || 3000;
```

This is a best practice that keeps secrets safe and allows configuration changes without modifying the codebase.

---

### ðŸ§± Express Middleware:
I learned that middleware functions are executed in sequence and can:
- Modify the `req` and `res` objects
- End the request-response cycle
- Call the next middleware using `next()`

I created a custom logger middleware like this:
```js
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();
});
```

Also used `express.json()` to parse JSON payloads and `express.static()` to serve static files.

---

### ðŸ“ Route Separation:
To keep my code cleaner, I moved all route logic into separate files:
```js
// routes/userRoutes.js
import express from 'express';
const router = express.Router();

router.get('/', (req, res) => {
  res.send('User route is working');
});

export default router;
```

Then used it in my main app:
```js
import userRoutes from './routes/userRoutes.js';
app.use('/api/users', userRoutes);
```

This made my project modular and easier to scale.

---

### ðŸ§  Reflections:
Today was about writing cleaner, scalable, and more secure backend code. Understanding how to manage environments and separate logic into different files is key for team collaboration and production-readiness.


final Summer training diary
3 months ago
I'm beginning to feel more like a real-world developer nowâ€”building not just "working code," but **maintainable code**.

first commit
4 months ago

---

âœ… **Next Goal:** Learn file uploads using `multer` and secure user routes using JWT authentication.



---


final Summer training diary
3 months ago
## Day 9 â€“ 2 July 2025  

first commit
4 months ago
### ðŸ“Œ Topics Covered:
Multer for File Uploads, Handling Multipart Forms, and Basic Image Storage

### ðŸ’» What I Did:
Today was all about enabling file uploads in my Node.js backend using the powerful middleware library **Multer**. I learned how to accept files like images and PDFs through API routes and store them on the local server.

---

### ðŸ“¦ Installing Multer:
First, I installed Multer:
```bash
npm install multer
```

Then configured it in my server:
```js
import multer from 'multer';

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/');
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

const upload = multer({ storage: storage });
```

This allowed me to control **where** and **how** files are stored.

---

### ðŸ“¤ Creating a File Upload Route:
I created a POST route to handle image uploads:
```js
app.post('/upload', upload.single('image'), (req, res) => {
  console.log(req.file);  // Access uploaded file info
  res.send('File uploaded successfully!');
});
```

Used `upload.single('image')` for single file and `upload.array('photos', 5)` for multiple uploads.

---


  console.error(err.stack);
  res.status(500).json({ message: 'Something went wrong!' });
});
```
  
I'm starting to feel more confident interacting with APIs and simulating frontend scenarios. The more I test, the clearer things become.

---

âœ… **Next Goal:** Implement request validation and explore `dotenv` for environment configs.



---
